namespace StrongTypeIdGenerator.Json
{
    using System;
    using System.ComponentModel;
    using System.Linq;
    using System.Reflection;
    using System.Text.Json;
    using System.Text.Json.Serialization;

    /// <summary>
    /// A JSON converter factory that provides seamless integration between System.Text.Json and strongly-typed identifiers
    /// generated by StrongTypeIdGenerator by leveraging their associated <see cref="TypeConverter"/> implementations.
    /// </summary>
    /// <remarks>
    /// This factory automatically detects types that have a <see cref="TypeConverterAttribute"/> applied (which all
    /// StrongTypeIdGenerator-generated types have) and creates appropriate JSON converters for them. The converters
    /// handle serialization to/from string representations and support both regular JSON values and property names
    /// (dictionary keys).
    /// 
    /// The factory works by:
    /// <list type="number">
    /// <item>Detecting types with <see cref="TypeConverterAttribute"/> in <see cref="CanConvert"/>.</item>
    /// <item>Creating a <see cref="TypeConverterJsonAdapter{T}"/> instance that wraps the type's <see cref="TypeConverter"/>.</item>
    /// <item>Using the TypeConverter's string conversion methods for JSON serialization/deserialization.</item>
    /// </list>
    /// 
    /// This approach ensures that any custom validation or transformation logic defined in the strongly-typed
    /// identifier's CheckValue method is respected during JSON operations.
    /// </remarks>
    /// <example>
    /// <para><strong>Basic Usage:</strong></para>
    /// <code>
    /// // Define a strongly-typed identifier
    /// [StringId]
    /// public partial class UserId { }
    /// 
    /// // Configure JSON serialization
    /// var options = new JsonSerializerOptions
    /// {
    ///     Converters = { new TypeConverterJsonConverterFactory() }
    /// };
    /// 
    /// // Use in your classes
    /// public class User
    /// {
    ///     public UserId Id { get; set; }
    ///     public string Name { get; set; }
    /// }
    /// 
    /// var user = new User { Id = new UserId("user-123"), Name = "John Doe" };
    /// 
    /// // Serialize to JSON
    /// string json = JsonSerializer.Serialize(user, options);
    /// // Result: {"Id":"user-123","Name":"John Doe"}
    /// 
    /// // Deserialize from JSON
    /// var deserializedUser = JsonSerializer.Deserialize&lt;User&gt;(json, options);
    /// </code>
    /// 
    /// <para><strong>Dictionary Keys Support:</strong></para>
    /// <code>
    /// // Works with strongly-typed identifiers as dictionary keys
    /// var userRoles = new Dictionary&lt;UserId, string&gt;
    /// {
    ///     { new UserId("user-1"), "Admin" },
    ///     { new UserId("user-2"), "User" }
    /// };
    /// 
    /// string json = JsonSerializer.Serialize(userRoles, options);
    /// // Result: {"user-1":"Admin","user-2":"User"}
    /// 
    /// var deserializedRoles = JsonSerializer.Deserialize&lt;Dictionary&lt;UserId, string&gt;&gt;(json, options);
    /// </code>
    /// 
    /// <para><strong>Global Configuration:</strong></para>
    /// <code>
    /// // Configure globally for ASP.NET Core applications
    /// public void ConfigureServices(IServiceCollection services)
    /// {
    ///     services.ConfigureHttpJsonOptions(options =>
    ///     {
    ///         options.SerializerOptions.Converters.Add(new TypeConverterJsonConverterFactory());
    ///     });
    ///     
    ///     services.Configure&lt;JsonOptions&gt;(options =>
    ///     {
    ///         options.SerializerOptions.Converters.Add(new TypeConverterJsonConverterFactory());
    ///     });
    /// }
    /// </code>
    /// 
    /// <para><strong>Custom Validation Support:</strong></para>
    /// <code>
    /// [StringId]
    /// public partial class ProductCode
    /// {
    ///     private static string CheckValue(string value)
    ///     {
    ///         if (string.IsNullOrWhiteSpace(value))
    ///             throw new ArgumentException("Product code cannot be empty");
    ///         
    ///         return value.ToUpperInvariant(); // Normalize to uppercase
    ///     }
    /// }
    /// 
    /// // JSON deserialization will respect the validation and normalization
    /// var json = """{"Code":"abc-123"}""";
    /// var product = JsonSerializer.Deserialize&lt;Product&gt;(json, options);
    /// // product.Code.Value will be "ABC-123" (uppercased)
    /// </code>
    /// </example>
    public class TypeConverterJsonConverterFactory : JsonConverterFactory
    {
        /// <summary>
        /// Determines whether the specified type can be converted by this factory.
        /// </summary>
        /// <param name="typeToConvert">The type to check for conversion support.</param>
        /// <returns>
        /// <c>true</c> if the type has a <see cref="TypeConverterAttribute"/> applied; otherwise, <c>false</c>.
        /// </returns>
        /// <remarks>
        /// This method checks if the type has any <see cref="TypeConverterAttribute"/> applied to it.
        /// All strongly-typed identifiers generated by StrongTypeIdGenerator automatically have this attribute,
        /// making them eligible for JSON conversion through this factory.
        /// </remarks>
        public override bool CanConvert(Type typeToConvert)
        {
            var hasConverter = typeToConvert.GetCustomAttributes<TypeConverterAttribute>().Any();
            return hasConverter;
        }

        /// <summary>
        /// Creates a JSON converter for the specified type.
        /// </summary>
        /// <param name="typeToConvert">The type for which to create a converter.</param>
        /// <param name="options">The JSON serializer options.</param>
        /// <returns>
        /// A <see cref="JsonConverter"/> instance that can handle the specified type, or <c>null</c> if creation fails.
        /// </returns>
        /// <remarks>
        /// This method retrieves the <see cref="TypeConverter"/> associated with the type and wraps it
        /// in a <see cref="TypeConverterJsonAdapter{T}"/> to provide JSON conversion capabilities.
        /// The created converter handles both regular JSON values and property names (for dictionary keys).
        /// </remarks>
        public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)
        {
            var converter = TypeDescriptor.GetConverter(typeToConvert);
            return (JsonConverter?)Activator.CreateInstance(
                typeof(TypeConverterJsonAdapter<>).MakeGenericType(typeToConvert),
                new object?[] { converter });
        }

        /// <summary>
        /// Internal JSON converter adapter that bridges between <see cref="TypeConverter"/> and <see cref="JsonConverter{T}"/>.
        /// </summary>
        /// <typeparam name="T">The strongly-typed identifier type to convert.</typeparam>
        /// <remarks>
        /// This adapter provides the actual JSON conversion logic by delegating to the underlying
        /// <see cref="TypeConverter"/>. It supports both regular JSON values and property names,
        /// making it suitable for use with strongly-typed identifiers as dictionary keys.
        /// </remarks>
        private sealed class TypeConverterJsonAdapter<T> : JsonConverter<T>
        {
            private readonly TypeConverter _typeConverter;

            /// <summary>
            /// Initializes a new instance of the <see cref="TypeConverterJsonAdapter{T}"/> class.
            /// </summary>
            /// <param name="typeConverter">The type converter to use for string conversions.</param>
            public TypeConverterJsonAdapter(TypeConverter typeConverter)
            {
                _typeConverter = typeConverter;
            }

            /// <summary>
            /// Reads and converts the JSON string value to a strongly-typed identifier.
            /// </summary>
            /// <param name="reader">The JSON reader.</param>
            /// <param name="typeToConvert">The type of the object to convert.</param>
            /// <param name="options">The JSON serializer options.</param>
            /// <returns>The converted strongly-typed identifier instance.</returns>
            /// <remarks>
            /// This method reads the JSON string value and uses the associated <see cref="TypeConverter"/>
            /// to create the strongly-typed identifier instance. Any validation or transformation logic
            /// defined in the identifier's CheckValue method will be applied.
            /// </remarks>
            public override T Read(
                ref Utf8JsonReader reader,
                Type typeToConvert,
                JsonSerializerOptions options)
            {
                var text = reader.GetString();
                return (T)_typeConverter.ConvertFromString(text!)!;
            }

            /// <summary>
            /// Writes the strongly-typed identifier as a JSON string value.
            /// </summary>
            /// <param name="writer">The JSON writer.</param>
            /// <param name="objectToWrite">The strongly-typed identifier to write.</param>
            /// <param name="options">The JSON serializer options.</param>
            /// <remarks>
            /// This method converts the strongly-typed identifier to its string representation using
            /// the associated <see cref="TypeConverter"/> and writes it as a JSON string value.
            /// If the object is <c>null</c>, a JSON null value is written.
            /// </remarks>
            public override void Write(
                Utf8JsonWriter writer,
                T objectToWrite,
                JsonSerializerOptions options)
            {

                if (objectToWrite == null)
                {
                    writer.WriteNullValue();
                    return;
                }

                var text = _typeConverter.ConvertToString(objectToWrite);
                writer.WriteStringValue(text);
            }

            /// <summary>
            /// Reads and converts a JSON property name to a strongly-typed identifier.
            /// </summary>
            /// <param name="reader">The JSON reader.</param>
            /// <param name="typeToConvert">The type of the object to convert.</param>
            /// <param name="options">The JSON serializer options.</param>
            /// <returns>The converted strongly-typed identifier instance.</returns>
            /// <remarks>
            /// This method enables strongly-typed identifiers to be used as dictionary keys in JSON.
            /// It reads the property name as a string and converts it to the identifier type using
            /// the associated <see cref="TypeConverter"/>.
            /// </remarks>
            public override T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var text = reader.GetString();
                return (T)_typeConverter.ConvertFromString(text!)!;
            }

            /// <summary>
            /// Writes the strongly-typed identifier as a JSON property name.
            /// </summary>
            /// <param name="writer">The JSON writer.</param>
            /// <param name="value">The strongly-typed identifier to write as a property name.</param>
            /// <param name="options">The JSON serializer options.</param>
            /// <remarks>
            /// This method enables strongly-typed identifiers to be used as dictionary keys in JSON.
            /// It converts the identifier to its string representation using the associated
            /// <see cref="TypeConverter"/> and writes it as a JSON property name.
            /// </remarks>
            public override void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
            {
                var text = _typeConverter.ConvertToString(value);
                writer.WritePropertyName(text!);
            }
        }
    }
}